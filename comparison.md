| Channel Types  | Coq | Z3 |
|---|-----|----|
| Sync | `Definition Sync (Input Output:Stream TD) : Prop :=`<br>  * `Teq Input Output /\ Deq Input Output.` | `def Sync(nodes, bound):`<br>`assert len(nodes) == 2`<br>`constraints = []`<br>`for i in range(bound):`<br>`constraints += [ nodes[0]['data'][i] == nodes[1]['data'][i] ]`<br>` constraints += [ nodes[0]['time'][i] == nodes[1]['time'][i]`<br>`return Conjunction(constraints)` |
| SyncDrain | `Definition SyncDrain (Input Output:Stream TD) : Prop :=`<br>`Teq Input Output.` | `def SyncDrain(nodes, bound):`<br> `assert len(nodes) == 2`<br> `constraints = []`<br> `for i in range(bound):`<br>`constraints += [nodes[0]['time'][i] == nodes[1]['time'][i]]`<br> ` return Conjunction(constraints) `|
| FIFO1 | `Definition FIFO1(Input Output:Stream TD) : Prop :=`<br>`Tle Input Output /\ Tle Output (tl Input) /\ Deq Input Output.` |     `def Fifo1(nodes, bound):`<br> `assert len(nodes) == 2`<br> `constraints = []`<br>`for i in range(bound):`<br>` constraints += [ nodes[0]['data'][i] == nodes[1]['data'][i] ]`<br> ` constraints += [ nodes[0]['time'][i] <  nodes[1]['time'][i] ]`<br> `if i != 0:`<br>`constraints += [ nodes[0]['time'][i] > nodes[1]['time'][i-1] ]`<br> `return Conjunction(constraints)` |
| FIFO1e | `Definition FIFO1e(Input Output:Stream TD)(e:Data) : Prop :=`<br> `Tgt Input Output /\ Tle Input (tl Output)`<br>`/\ PrR (hd`  `Output) = e  /\ Deq Input (tl Output).` |  `def Fifo1e(e):`<br>`def Fifo1eInstance(nodes, bound):`<br> ` assert len(nodes) == 2`<br> ` constraints = []`<br> `constraints += [nodes[1]['data'][0] == 1]`<br> `for i in range(bound-1):`<br>  ` constraints += [nodes[0]['data'][i] == nodes[1]['data'][i + 1]]`<br>`constraints += [nodes[0]['time'][i] < nodes[1]['time'][i + 1]]`<br> `for i in range(bound):`<br>`constraints += [nodes[0]['time'][i] > nodes[1]['time'][i]]`<br> `return Conjunction(constraints)`<br> ` return Fifo1eInstance `|
| LossySync | `Parameter LossySync: Stream TD -> Stream TD -> Prop.`<br>`Axiom LossySync_coind: forall Input Output: Stream TD,`<br>`LossySync Input Output ->`<br>`(( hd Output = hd Input  /\ LossySync (tl Input)(tl Output)) \/`<br>`LossySync(tl Input) Output).`| `def LossySync(nodes, bound, idx = 0, num = 0):`<br> ` assert len(nodes) == 2`<br>`if bound == num:`<br>   `return True`<br> `if bound == idx:`<br>   `return True`<br> `constraints_0 = []`<br>  `constraints_1 = []`<br>  `constraints_0 += [ nodes[0]['time'][idx] != nodes[1]['time'][num]]  `<br> `constraints_1 += [ nodes[0]['data'][idx] == nodes[1]['data'][num]]`<br>`constraints_1 += [ nodes[0]['time'][idx] == nodes[1]['time'][num]]`<br>`return Or(And(Conjunction(constraints_0), Channel.LossySync(nodes, bound, idx + 1, num)),`<br> `And(Conjunction(constraints_1), Channel.LossySync(nodes, bound, idx + 1, num + 1)))` |
| Merge(r) | `Parameter merge: Stream TD -> Stream TD ->Stream TD -> Prop.`<br>`Axiom merge_coind:`<br>`forall s1 s2 s3:Stream TD,`<br> `merge s1 s2 s3-> (`<br> `~ (PrL(hd s1) = PrL(hd s2)) /\`<br>`( (PrL(hd s1) < PrL(hd s2)) -> ((hd s3 = hd s1)  /\ merge (tl s1) s2 (tl s3)) ) /\ `<br> `( (PrL(hd s1) > PrL(hd s2)) -> ((hd s3 = hd s2)  /\ merge s1 (tl s2) (tl s3)) ) ). `| `def Merger(nodes, bound, idx_1 = 0, idx_2 = 0):`<br>`assert len(nodes) == 3`<br>   `if bound == idx_1 + idx_2:`<br>   ` return True`<br>     `constraints_1 = []`<br> `constraints_2 = []`<br>     `constraints_1 += [ nodes[0]['data'][idx_1] == nodes[2]['data'][idx_1 + idx_2]]`<br>    `constraints_1 += [ nodes[0]['time'][idx_1] == nodes[2]['time'][idx_1 + idx_2]]`<br> `constraints_1 += [ nodes[0]['time'][idx_1] <  nodes[1]['time'][idx_2]]`<br> `constraints_2 += [ nodes[1]['data'][idx_2] == nodes[2]['data'][idx_1 + idx_2]]`<br>     `constraints_2 += [ nodes[1]['time'][idx_2] == nodes[2]['time'][idx_1 + idx_2]]`<br>    ` constraints_2 += [ nodes[1]['time'][idx_2] <  nodes[0]['time'][idx_1]]`<br>  ` return Or(And(Conjunction(constraints_1), Channel.Merger(nodes, bound, idx_1 + 1, idx_2)),`<br>          `And(Conjunction(constraints_2), Channel.Merger(nodes, bound, idx_1, idx_2 + 1)))` |
