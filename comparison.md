Essentially, the definitions of channles are formalized according to the behavior of different channels, which can also be regarded as the requirements the channels should satisfy. In Coq, the formalization of these requirements is in form of predicates while the formalization in Z3 is in form of constraints.

| Channel Types  | Coq | Z3 |
|---|-----|----|
| Sync | `Definition Sync (Input Output:Stream TD) : Prop :=`<br> &nbsp; &nbsp; `Teq Input Output /\ Deq Input Output.` | `def Sync(nodes, bound):`<br> &nbsp; &nbsp; `assert len(nodes) == 2`<br> &nbsp; &nbsp; `constraints = []`<br> &nbsp; &nbsp; `for i in range(bound):`<br> &nbsp; &nbsp;&nbsp; &nbsp; `constraints += [ nodes[0]['data'][i] == nodes[1]['data'][i] ]`<br> &nbsp; &nbsp;&nbsp; &nbsp; `constraints += [ nodes[0]['time'][i] == nodes[1]['time'][i]`<br> &nbsp; &nbsp; `return Conjunction(constraints)` |
| SyncDrain | `Definition SyncDrain (Input Output:Stream TD) : Prop :=`<br> &nbsp; &nbsp; `Teq Input Output.` | `def SyncDrain(nodes, bound):`<br> &nbsp; &nbsp; `assert len(nodes) == 2`<br> &nbsp; &nbsp; `constraints = []`<br> &nbsp; &nbsp; `for i in range(bound):`<br> &nbsp; &nbsp;&nbsp; &nbsp; `constraints += [nodes[0]['time'][i] == nodes[1]['time'][i]]`<br> &nbsp; &nbsp; `return Conjunction(constraints) `|
| FIFO1 | `Definition FIFO1(Input Output:Stream TD) : Prop :=`<br> &nbsp; &nbsp; `Tle Input Output /\ Tle Output (tl Input) /\ Deq Input Output.` |     `def Fifo1(nodes, bound):`<br> &nbsp; &nbsp; `assert len(nodes) == 2`<br> &nbsp; &nbsp; `constraints = []`<br> &nbsp; &nbsp; `for i in range(bound):`<br>&nbsp; &nbsp;&nbsp; &nbsp;`constraints += [ nodes[0]['data'][i] == nodes[1]['data'][i] ]`<br> &nbsp; &nbsp;&nbsp; &nbsp; `constraints += [ nodes[0]['time'][i] <  nodes[1]['time'][i] ]`<br> &nbsp; &nbsp;&nbsp; &nbsp; `if i != 0:`<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;`constraints += [ nodes[0]['time'][i] > nodes[1]['time'][i-1] ]`<br> &nbsp; &nbsp;`return Conjunction(constraints)` |
| FIFO1e | `Definition FIFO1e(Input Output:Stream TD)(e:Data) : Prop :=`<br> &nbsp; &nbsp; `Tgt Input Output /\ Tle Input (tl Output)`<br> &nbsp; &nbsp; `/\ PrR (hd`  `Output) = e  /\ Deq Input (tl Output).` |  `def Fifo1e(e):`<br> &nbsp; &nbsp; `def Fifo1eInstance(nodes, bound):`<br> &nbsp; &nbsp;&nbsp; &nbsp; `assert len(nodes) == 2`<br> &nbsp; &nbsp;&nbsp; &nbsp; `constraints = []`<br> &nbsp; &nbsp;&nbsp; &nbsp; `constraints += [nodes[1]['data'][0] == e]`<br> &nbsp; &nbsp;&nbsp; &nbsp; `for i in range(bound-1):`<br>  &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;`constraints += [nodes[0]['data'][i] == nodes[1]['data'][i + 1]]`<br> &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;`constraints += [nodes[0]['time'][i] < nodes[1]['time'][i + 1]]`<br> &nbsp; &nbsp;&nbsp; &nbsp; `for i in range(bound):`<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;`constraints += [nodes[0]['time'][i] > nodes[1]['time'][i]]`<br> &nbsp; &nbsp;&nbsp; &nbsp; `return Conjunction(constraints)`<br> &nbsp; &nbsp;&nbsp; &nbsp;`return Fifo1eInstance `|
| LossySync | `Parameter LossySync: Stream TD -> Stream TD -> Prop.`<br>`Axiom LossySync_coind:` <br> &nbsp; &nbsp; `forall Input Output: Stream TD,`<br> &nbsp; &nbsp; `LossySync Input Output ->`<br> &nbsp; &nbsp; `(( hd Output = hd Input  /\ `<br> &nbsp; &nbsp;`LossySync (tl Input)(tl Output)) \/`<br>`LossySync(tl Input) Output).`| `def LossySync(nodes, bound, idx = 0, num = 0):`<br> &nbsp; &nbsp;` assert len(nodes) == 2`<br>&nbsp; &nbsp;`if bound == num:`<br>   &nbsp; &nbsp;&nbsp; &nbsp;`return True`<br>&nbsp; &nbsp; `if bound == idx:`<br>  &nbsp; &nbsp;&nbsp; &nbsp; `return True`<br> &nbsp; &nbsp; `constraints_0 = []`<br> &nbsp; &nbsp; `constraints_1 = []`<br> &nbsp; &nbsp; `constraints_0 += [ nodes[0]['time'][idx] != nodes[1]['time'][num]]  `<br> &nbsp; &nbsp; `constraints_1 += [ nodes[0]['data'][idx] == nodes[1]['data'][num]]`<br>&nbsp; &nbsp; `constraints_1 += [ nodes[0]['time'][idx] == nodes[1]['time'][num]]`<br>&nbsp; &nbsp; `return Or(And(Conjunction(constraints_0), Channel.LossySync(nodes, bound, idx + 1, num)),`<br> &nbsp; &nbsp;&nbsp; &nbsp;`And(Conjunction(constraints_1), Channel.LossySync(nodes, bound, idx + 1, num + 1)))` |
| Merge(r) | `Parameter merge: Stream TD -> Stream TD ->Stream TD -> Prop.`<br>`Axiom merge_coind:`<br> &nbsp; &nbsp; `forall s1 s2 s3:Stream TD,`<br> &nbsp; &nbsp; `merge s1 s2 s3-> (`<br> &nbsp; &nbsp; `~ (PrL(hd s1) = PrL(hd s2)) /\`<br> &nbsp; &nbsp; `( (PrL(hd s1) < PrL(hd s2)) -> ((hd s3 = hd s1)  /\ merge (tl s1) s2 (tl s3)) ) /\ `<br> &nbsp; &nbsp; `( (PrL(hd s1) > PrL(hd s2)) -> ((hd s3 = hd s2)  /\ merge s1 (tl s2) (tl s3)) ) ). `| `def Merger(nodes, bound, idx_1 = 0, idx_2 = 0):`<br> &nbsp; &nbsp; `assert len(nodes) == 3`<br>  &nbsp; &nbsp; `if bound == idx_1 + idx_2:`<br>   &nbsp; &nbsp;&nbsp; &nbsp; ` return True`<br>   &nbsp; &nbsp;  `constraints_1 = []`<br> &nbsp; &nbsp; `constraints_2 = []`<br>   &nbsp; &nbsp;  `constraints_1 += [ nodes[0]['data'][idx_1] == nodes[2]['data'][idx_1 + idx_2]]`<br> &nbsp; &nbsp;   `constraints_1 += [ nodes[0]['time'][idx_1] == nodes[2]['time'][idx_1 + idx_2]]`<br> &nbsp; &nbsp; `constraints_1 += [ nodes[0]['time'][idx_1] <  nodes[1]['time'][idx_2]]`<br> &nbsp; &nbsp; `constraints_2 += [ nodes[1]['data'][idx_2] == nodes[2]['data'][idx_1 + idx_2]]`<br> &nbsp; &nbsp;    `constraints_2 += [ nodes[1]['time'][idx_2] == nodes[2]['time'][idx_1 + idx_2]]`<br>  &nbsp; &nbsp;  ` constraints_2 += [ nodes[1]['time'][idx_2] <  nodes[0]['time'][idx_1]]`<br>  &nbsp; &nbsp; `return Or(And(Conjunction(constraints_1), Channel.Merger(nodes, bound, idx_1 + 1, idx_2)),`<br> &nbsp; &nbsp;&nbsp; &nbsp;         `And(Conjunction(constraints_2), Channel.Merger(nodes, bound, idx_1, idx_2 + 1)))` |
